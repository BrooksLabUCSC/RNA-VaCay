#!/usr/bin/env python3
# Name: Jon Akutagawa
# Date: 19-03-21

"""
This script loads VCF files generated by variant callers and compares their
results. Variant callers were fed synthetic data with defined mutations, so
overlap between variant calls from each tool was measured. Metrics are output as
Venn diagrams.

input: folder locations of VCF files generated by paired data runs on MuTect2,
Platypus, and/or VarDict, original bam file, panel of normals VCF

output:
venn diagram of variant calls from each tool

sample commands:
python compare_calls.py -pl /scratch/jakutagawa/icgc/var_calls/platypus/ \
 -vd /scratch/jakutagawa/icgc/var_calls/vardict/ \
 -mt /scratch/jakutagawa/icgc/var_calls/mutect2/ \
 -ml /private/groups/brookslab/jakutagawa/variant_calling/synthetic_mutation_lists/ \
 -pon /scratch/jakutagawa/icgc/bams/gtex/pon/pon.vcf \
 -b /scratch/jakutagawa/icgc/bams/synthetic/spiked/PCAWG.23e76a4f-9e4c-4aed-a46d-d9cbc1336250.STAR.v1.with_variants.bam


python compare_calls.py -pl /scratch/jakutagawa/icgc/var_calls/platypus/ \
 -vd /scratch/jakutagawa/icgc/var_calls/vardict/ \
 -mt /scratch/jakutagawa/icgc/var_calls/mutect2/ \
 -ml /private/groups/brookslab/jakutagawa/variant_calling/synthetic_mutation_lists/ \
 -pon /scratch/jakutagawa/icgc/bams/gtex/pon/pon.vcf \
 -b /scratch/jakutagawa/icgc/bams/synthetic/spiked/PCAWG.3df6d1f5-0f57-499b-8914-153e1ec52b0a.STAR.v1.with_variants.bam

 python compare_calls.py -pl /scratch/jakutagawa/icgc/var_calls/platypus/ \
  -vd /scratch/jakutagawa/icgc/var_calls/vardict/ \
  -mt /scratch/jakutagawa/icgc/var_calls/mutect2/ \
  -ml /private/groups/brookslab/jakutagawa/variant_calling/synthetic_mutation_lists/ \
  -pon /scratch/jakutagawa/icgc/bams/gtex/pon/pon.vcf \
  -b /scratch/jakutagawa/icgc/bams/synthetic/spiked/PCAWG.5c149622-df1c-427d-9bf0-fef9a4631b2f.STAR.v1.with_variants.bam

python compare_calls.py -pl /scratch/jakutagawa/icgc/var_calls/platypus/ \
 -vd /scratch/jakutagawa/icgc/var_calls/vardict/ \
 -mt /scratch/jakutagawa/icgc/var_calls/mutect2/ \
 -ml /private/groups/brookslab/jakutagawa/variant_calling/synthetic_mutation_lists/ \
 -pon /scratch/jakutagawa/icgc/bams/gtex/pon/pon.vcf \
 -b /scratch/jakutagawa/icgc/bams/synthetic/spiked/PCAWG.66b0260b-f242-4eea-9c9f-a96e1ec7f0f9.STAR.v1.with_variants.bam
"""

import sys
from multiprocessing import Pool

import pysam
import os

#import numpy as np
import matplotlib
matplotlib.use('Agg')
#import seaborn as sns; sns.set()
import matplotlib.pyplot as plt
from matplotlib_venn import venn3
#import matplotlib.patches as mplpatches
#from matplotlib.lines import Line2D

def get_matching_normal_bam_filename(mutation_list_filename):
    """
    Get filename of matching normal bam
    """
    base_filename = mutation_list_filename.split('/')[-1]
    matching_normal = '/scratch/jakutagawa/icgc/bams/normal/' + \
                      base_filename.strip('.random_snp_only.txt') + '.bam'

    return matching_normal

def get_filenames(bam_filename, platypus_folder, vardict_folder, mutect_folder,
                  synthetic_mutation_lists_folder):
    """
    Get filenames of each VCF associated with the bam based on user-defined
    folder locations
    """
    base_filename = bam_filename.split('/')[-1]
    id = base_filename.split('.')[1]

    mutant_platypus_vcf = platypus_folder + id + '.spiked.vcf'
    normal_platypus_vcf = platypus_folder + id + '.normal.vcf'
    mutant_mutect_vcf = mutect_folder + id + '.mutant.vcf'
    normal_mutect_vcf = mutect_folder + id + '.normal.vcf'
    mutant_vardict_vcf = vardict_folder + 'spiked/' + id + '/' + id + '.out.vcf'
    normal_vardict_vcf = vardict_folder + 'normal/' + id + '/' + id + '.out.vcf'
    mutation_list_file = synthetic_mutation_lists_folder + \
                         base_filename.strip('.with_variants.bam') + '.random_snp_only.txt'
    matching_files = [mutant_platypus_vcf, normal_platypus_vcf, mutant_vardict_vcf,
                      normal_vardict_vcf, mutant_mutect_vcf, normal_mutect_vcf]

    sys.stderr.write('matching matching mutation list at ' + str(mutation_list_file) + '\n')
    sys.stderr.write('vcfs at ' + str(matching_files) + '\n')

    return mutation_list_file, matching_files


def load_mutation_list (mutation_list_filename):
    """
    Load mutations spiked into the synthetic data
    """
    #bamfile = pysam.AlignmentFile(bam_filename, "rb" )
    counter = 0
    mutations_dict = dict()
    normal_bam_filename = get_matching_normal_bam_filename(mutation_list_filename)

    for chrom,pos1,pos2,vaf,mut_base,mut_type in read_mutation_list(mutation_list_filename):
        counter += 1
        #new_base = mutation.split('>')[1]
        #mut_entry = (chrom,pos1,pos2,vaf,mut_base,mut_type)
        mut_entry = (chrom,pos1,mut_base)
        depth = get_coverage(normal_bam_filename, mut_entry)
        #depth = 1
        mutations_dict[mut_entry] = (float(vaf), int(depth))
        #mutations_dict[mut_entry] = 1
        #vaf_dict[mut_entry] = vaf
        #if counter % 10000 == 0:
        #    sys.stderr.write('loaded ' + str(counter) + ' mutations \n')
    #print (get_coverage(bam_filename,mut_entry))

    #print (mutations_list[0])
    sys.stderr.write('loaded ' + mutation_list_filename + '\n')
    return mutations_dict

def load_pon (pon_filename):
    """
    Load panel of normals generated by MuTect2
    """
    pon_list = list()
    if pon_filename:
        counter = 0

        for chrom,pos1,ref_base,var_base in read_vcf(pon_filename,'pon'):
            counter += 1
            #new_base = mutation.split('>')[1]
            #mut_entry = (chrom,pos1,ref_base,var_base)
            mut_entry = (chrom,pos1,var_base)
            pon_list.append(mut_entry)
            #if counter % 10000 == 0:
            #    sys.stderr.write('loaded ' + str(counter) + ' mutations \n')

        sys.stderr.write('loaded ' + pon_filename + '\n')
        return pon_list
    else:
        sys.stderr.write('no pon specified\n')
        return pon_list


def load_vcf (vcf_filename):
    """
    Load VCF data into a list of tuples
    """
    counter = 0
    mutations_list = list()
    file_origin = get_file_origin(vcf_filename)
    #print (mutect_depths)

    for chrom,pos1,ref_base,var_base in read_vcf(vcf_filename,file_origin):
        counter += 1
        #new_base = mutation.split('>')[1]
        #mut_entry = (chrom,pos1,ref_base,var_base)
        mut_entry = (chrom,pos1,var_base)
        mutations_list.append(mut_entry)
        #if counter % 10000 == 0:
        #    sys.stderr.write('loaded ' + str(counter) + ' mutations \n')

    sys.stderr.write('loaded ' + vcf_filename + '\n')
    return mutations_list

def get_file_origin(vcf_file):
    """
    Determine which variant caller generated the VCF
    """
    if 'mutect' in vcf_file.lower():
        file_origin = 'mutect'
    elif 'vardict' in vcf_file.lower():
        file_origin = 'vardict'
    elif 'platypus' in vcf_file.lower():
        file_origin = 'platypus'

    return file_origin

def read_vcf (vcf_filename,file_origin):
    """
    Read in VCF and parse line for necessary values.
    """
    #global mutect_depths

    with open(vcf_filename) as fileH:
        # read the header
        header_counter = 0
        while True:
            line = fileH.readline()
            header_counter += 1
            if not line.startswith('#'):
                break

        for line in fileH:
            if file_origin == 'vardict':
                split_line = line.rstrip().split(' \t ')
            else:
                split_line = line.rstrip().split('\t')
            chrom = split_line[0]
            try:
                pos1 = int(split_line[1])
            except ValueError:
                continue
                #sys.stderr.write('line begins with &\n')
            ref_base = split_line[3]
            var_base = split_line[4]
            info = split_line[7]
            split_info = info.split(';')


            if file_origin == 'mutect':
                for info_type in split_info:
                    if info_type.split('=')[0] == 'DP':
                        depth = info_type.split('=')[1]
                        #mutect_depths[(chrom,pos1,var_base)] = depth

                        #print (depth)
                    if info_type.split('=')[0] == 'TLOD':
                        tlod = float(info_type.split('=')[1].split(',')[0])
                tumor_info = split_line[9]
                split_tumor_info = tumor_info.split(':')

            #if file_origin == 'platypus':



            if not line.startswith('&'):
                yield chrom,pos1,ref_base,var_base

#sys.stderr.write('loaded ' + str(counter) + ' mutations \n')


def load_all_vcfs (file_list, variant_caller):
    """
    Read in all variants from VCF files simultaneously using Pool
    """
    p = Pool()
    mutant_vcf_dict = dict()
    normal_vcf_dict = dict()
    complete_vcf_trio = list()

    vcf_lists = p.map(load_vcf, file_list)

    for index, file in enumerate(file_list):
        if variant_caller == 'vardict':
            id = file.split('/')[-2]
        elif variant_caller == 'platypus':
            basefile = file.split('/')[-1]
            id = basefile.split('.')[-3]
        elif variant_caller == 'mutect':
            basefile = file.split('/')[-1]
            id = basefile.split('.')[0]

        if 'spiked' in file:
            mutant_vcf_list = vcf_lists[index]
        elif 'mutant' in file:
            mutant_vcf_list = vcf_lists[index]
        elif 'normal' in file:
            normal_vcf_list = vcf_lists[index]

    return mutant_vcf_list, normal_vcf_list

def read_mutation_list (mutation_list_filename):
    """
    Read in VCF and parse line for necessary values.
    """
    with open(mutation_list_filename) as fileH:
        for line in fileH:
            split_line = line.rstrip().split('\t')
            chrom = split_line[0]
            pos1 = int(split_line[1])
            pos2 = int(split_line[2])
            vaf = split_line[3]
            mut_base = split_line[4]
            mut_type = split_line[5]

            yield chrom,pos1,pos2,vaf,mut_base,mut_type

def print_comparison_lists (platypus_variants, vardict_variants, mutect_variants, cleaned_mutation_dict):
    """
    Print lists of variants depending on their class (false negative,
    true positive, etc.). Print to screen as error currently.
    """
    all_mutant_variants = list(platypus_variants) + list(vardict_variants) + list(mutect_variants)
    platypus_only = list(set(platypus_variants) - set(vardict_variants) - set(mutect_variants))
    vardict_only = list(set(vardict_variants) - set(platypus_variants) - set(mutect_variants))
    mutect_only = list(set(mutect_variants) - set(platypus_variants) - set(vardict_variants))
    platypus_vardict = list(set(platypus_variants) - set(mutect_variants) - set(vardict_only) - set(platypus_only))
    mutect_vardict = list(set(mutect_variants) - set(platypus_variants)- set(mutect_only) - set(vardict_only))
    platypus_mutect = list(set(platypus_variants) - set(vardict_variants)- set(platypus_only) - set(mutect_only))
    all_three =  list(set(all_mutant_variants) - set(platypus_only) - set(vardict_only)
                      - set(mutect_only) - set(platypus_vardict) - set(mutect_vardict)
                      - set(platypus_mutect))

    sys.stderr.write('**false negatives**\n')
    platypus_false_negatives = set(cleaned_mutation_dict.keys()) - set(platypus_variants)
    vardict_false_negatives = set(cleaned_mutation_dict.keys()) - set(vardict_variants)
    mutect_false_negatives = set(cleaned_mutation_dict.keys()) - set(mutect_variants)

    # must be missed by all three (intersection)
    consensus_false_negatives = set(cleaned_mutation_dict.keys()) - set(platypus_variants & vardict_variants & mutect_variants)
    # must be missed by just one tool (union)
    any_false_negatives = set(cleaned_mutation_dict.keys()) - set(platypus_variants | vardict_variants | mutect_variants)
    sys.stderr.write ('platypus: {0}\n'.format(platypus_false_negatives))
    sys.stderr.write ('vardict: {0}\n'.format(vardict_false_negatives))
    sys.stderr.write ('mutect: {0}\n'.format(mutect_false_negatives))
    sys.stderr.write ('consensus: {0}\n'.format(consensus_false_negatives))
    sys.stderr.write ('any: {0}\n'.format(any_false_negatives))

    sys.stderr.write('**depth and vafs of false negatives**\n')
    platypus_vafs_depths = list()
    vardict_vafs_depths = list()
    mutect_vafs_depths = list()
    any_vafs_depths = list()
    for negative in platypus_false_negatives:
        platypus_vafs_depths.append(cleaned_mutation_dict[negative])
    sys.stderr.write ('platypus: {0}\n'.format(platypus_vafs_depths))
    for negative in vardict_false_negatives:
        vardict_vafs_depths.append(cleaned_mutation_dict[negative])
    sys.stderr.write ('vardict: {0}\n'.format(vardict_vafs_depths))
    for negative in mutect_false_negatives:
        mutect_vafs_depths.append(cleaned_mutation_dict[negative])
    sys.stderr.write ('mutect: {0}\n'.format(mutect_vafs_depths))
    for negative in list(any_false_negatives):
        any_vafs_depths.append(cleaned_mutation_dict[negative])
    sys.stderr.write ('any: {0}\n'.format(any_vafs_depths))

    sys.stderr.write ('**true positives found by only one tool**\n')
    platypus_only_true_positives = set(platypus_only) & set(cleaned_mutation_dict.keys())
    vardict_only_true_positives = set(vardict_only) & set(cleaned_mutation_dict.keys())
    mutect_only_true_positives = set(mutect_only) & set(cleaned_mutation_dict.keys())
    sys.stderr.write ('platypus: {0}\n'.format(platypus_only_true_positives))
    sys.stderr.write ('vardict: {0}\n'.format(vardict_only_true_positives))
    sys.stderr.write ('mutect: {0}\n'.format(mutect_only_true_positives))

    sys.stderr.write ('**false positives**\n')
    platypus_only_false_positives = set(platypus_only) - set(cleaned_mutation_dict.keys())
    vardict_only_false_positives = set(vardict_only) - set(cleaned_mutation_dict.keys())
    mutect_only_false_positives = set(mutect_only) - set(cleaned_mutation_dict.keys())
    platypus_vardict_false_positives = set(platypus_vardict) - set(cleaned_mutation_dict.keys())
    platypus_mutect_false_positives = set(platypus_mutect) - set(cleaned_mutation_dict.keys())
    mutect_vardict_false_positives = set(mutect_vardict) - set(cleaned_mutation_dict.keys())
    all_three_false_positives = set(all_three) - set(cleaned_mutation_dict.keys())
    sys.stderr.write ('platypus only: {0}\n'.format(platypus_only_false_positives))
    sys.stderr.write ('vardict only: {0}\n'.format(vardict_only_false_positives))
    sys.stderr.write ('mutect only: {0}\n'.format(mutect_only_false_positives))
    sys.stderr.write ('platypus & vardict: {0}\n'.format(platypus_vardict_false_positives))
    sys.stderr.write ('platypus & mutect: {0}\n'.format(platypus_mutect_false_positives))
    sys.stderr.write ('mutect & vardict: {0}\n'.format(mutect_vardict_false_positives))
    sys.stderr.write ('all three: {0}\n'.format(all_three_false_positives))


def compare_mutations (platypus_vcfs, vardict_vcfs, mutect_vcfs, cleaned_mutation_dict, pon_list, id):
    """
    Determine which variant calls overlap.
    """
    platypus_variants = set(platypus_vcfs[0]) - set(platypus_vcfs[1]) - set(pon_list)# - set(cleaned_mutation_dict.keys())
    vardict_variants = set(vardict_vcfs[0]) - set(vardict_vcfs[1]) - set(pon_list)# - set(cleaned_mutation_dict.keys())
    mutect_variants = set(mutect_vcfs[0]) - set(mutect_vcfs[1]) - set(pon_list)# - set(cleaned_mutation_dict.keys())

    all_mutant_variants = list(platypus_variants) + list(vardict_variants) + list(mutect_variants)

    platypus_only = list(set(platypus_variants) - set(vardict_variants) - set(mutect_variants))
    vardict_only = list(set(vardict_variants) - set(platypus_variants) - set(mutect_variants))
    mutect_only = list(set(mutect_variants) - set(platypus_variants) - set(vardict_variants))
    platypus_vardict = list(set(platypus_variants) - set(mutect_variants) - set(vardict_only) - set(platypus_only))
    mutect_vardict = list(set(mutect_variants) - set(platypus_variants)- set(mutect_only) - set(vardict_only))
    platypus_mutect = list(set(platypus_variants) - set(vardict_variants)- set(platypus_only) - set(mutect_only))
    all_three =  list(set(all_mutant_variants) - set(platypus_only) - set(vardict_only)
                      - set(mutect_only) - set(platypus_vardict) - set(mutect_vardict)
                      - set(platypus_mutect))


    print_comparison_lists(platypus_variants, vardict_variants, mutect_variants, cleaned_mutation_dict)

    venn3 (subsets = (len(platypus_only),len(vardict_only),len(platypus_vardict),len(mutect_only),len(platypus_mutect),len(mutect_vardict),len(all_three)), set_labels = ('Platypus', 'VarDict', 'MuTect2'))

    filename = 'spiked_venn_' + id + '.pdf'
    plt.savefig(filename)


def clean_mutation_list (mutations_dict, reference_fasta):
    """
    Remove mutations that have the same base as the spiked mutation
    """
    cleaned_mutation_dict = dict()
    removed_mutations = list()
    for mutation, vaf_depth in mutations_dict.items():
        chrom = mutation[0]
        pos1 = mutation[1]
        #pos2 = mutation[2]
        mut_base = mutation[2]
        location = chrom + ':' + str(pos1) + '-' + str(pos1)
        #pileup = pysam.mpileup("-O","-r", location, "-f", reference_fasta, bam_filename)
        faidx = pysam.faidx(reference_fasta, location)

        #mutation_depth = pysam.depth("-r", location, bam_filename)
        mutation_depth = vaf_depth[1]
        #print ('for mutation: ' + str(mutation))
        #try:
        #    depth = mutation_depth.rstrip().split('\t')[2]
        #except IndexError:
        #    depth = 0

        ref_base = faidx.rstrip().split('\n')[1]
        #try:
        #    ref_base = pileup.rstrip().split('\t')[2]
        #except IndexError:
        #    ref_base = 0

        if mut_base == ref_base or mutation_depth == 0 or ref_base == 0:
            removed_mutations.append(mutation)
        else:
            cleaned_mutation_dict[mutation] = vaf_depth

    #cleaned_all_mutations_dict[id] = cleaned_mutation_dict
    #all_removed_mutations_dict[id] = removed_mutations
    sys.stderr.write('removed ' + str(len(removed_mutations)))
    sys.stderr.write(' mutations with 0 reads or trivial mutation\n')
    return cleaned_mutation_dict


def get_coverage (bam_filename, mutation):
    """
    Get coverage at a variant location using pysam.
    """
    #print(depth_line.rstrip().split('\t')[2])
    #all_depths = list()
    #for mutation in spiked_mutation_dict.keys():
    chrom = mutation[0]
    pos1 = mutation[1]
    location = chrom + ':' + str(pos1) + '-' + str(pos1)
    depth_line = pysam.depth("-r",location,bam_filename)
    #print (mutation)
    #print (depth_line.rstrip().split('\t'))

    split_depth = depth_line.rstrip().split('\t')
    if split_depth[0]:
        depth = split_depth[2]
        return depth
    else:
        return 0


class CommandLine() :
    """
    modified from David Bernick

    Handle the command line, usage and help requests.

    CommandLine uses argparse, now standard in 2.7 and beyond.
    it implements a standard command line argument parser with various argument options,
    a standard usage and help, and an error termination mechanism do-usage_and_die.

    attributes:
    my_command_line.args is a dictionary which includes each of the available command line arguments as
    my_command_line.args['option']
    """

    def __init__(self, inOpts=None) :
        """
        CommandLine constructor.
        Implements a parser to interpret the command line argv string using argparse.
        """
        import argparse
        self.parser = argparse.ArgumentParser(description = 'Program prolog - Specify the input files and conditions',
                                             epilog = 'Program epilog - parameters of infiles must be given.',
                                             add_help = True, #default is True
                                             prefix_chars = '-',
                                             usage = '%(prog)s -pl pfolder -vd vfolder -mt mfolder -ml mutations -pon pon -b bam'
                                             )

        self.parser.add_argument('-pl','--platypusFolder', dest='platypus_folder',
                                 action='store', type=str, required=False,
                                 default=None,
                                 help='location of platypus vcf files')
        self.parser.add_argument('-vd','--vardictFolder', dest='vardict_folder',
                                 action='store', type=str, required=False,
                                 default=None,
                                 help='location of vardict vcf files')
        self.parser.add_argument('-mt','--mutectFolder', dest='mutect_folder',
                                 action='store', type=str, required=False,
                                 default=None,
                                 help='location of mutect vcf files')

        self.parser.add_argument('-ml','--mutationLists', dest='mutation_list_folder',
                                 action='store', type=str, required=True,
                                 help='list of mutations spiked into synthetic data')

        self.parser.add_argument('-pon','--panelOfNormals', dest='pon_filename',
                                 action='store', type=str, required=False,
                                 default=None,
                                 help='panel of normal variants filename')

        self.parser.add_argument('-b','--bam', dest='bam_filename',
                                 action='store', type=str, required=True,
                                 help='mutant bam location')
        """
        self.parser.add_argument('-of','--outputFile', dest='output_file',
                                 action='store',type=str, required=True,
                                 help='output data filename')
        """


        if inOpts is None :
            self.args = self.parser.parse_args()
        else :
            self.args = self.parser.parse_args(inOpts)


def main(my_command_line=None):
    """
    Load VCFs. Compare detected mutations with
    a known list. Output counts as lists in a text file.
    """
    my_command_line = CommandLine(my_command_line)

    bam_filename = my_command_line.args.bam_filename
    synthetic_mutation_lists_folder = my_command_line.args.mutation_list_folder
    platypus_folder = my_command_line.args.platypus_folder
    vardict_folder = my_command_line.args.vardict_folder
    mutect_folder = my_command_line.args.mutect_folder
    pon_filename = my_command_line.args.pon_filename
    reference_fasta = '/private/groups/brookslab/reference_indices/hs37/hs37d5.fa'

    mutation_list_filename, vcf_filelist = get_filenames(bam_filename, platypus_folder,
                vardict_folder, mutect_folder, synthetic_mutation_lists_folder)
    pon_list = load_pon(pon_filename)

    id = mutation_list_filename.split('/')[-1].split('.')[1]

    spiked_mutation_dict = load_mutation_list(mutation_list_filename)
    cleaned_mutation_dict = clean_mutation_list(spiked_mutation_dict, reference_fasta)

    platypus_vcfs = load_all_vcfs(vcf_filelist[0:2], 'platypus')
    vardict_vcfs = load_all_vcfs(vcf_filelist[2:4], 'vardict')
    mutect_vcfs = load_all_vcfs(vcf_filelist[4:6], 'mutect')

    compare_mutations(platypus_vcfs, vardict_vcfs, mutect_vcfs, cleaned_mutation_dict, pon_list, id)



if __name__ == "__main__":
    main()
